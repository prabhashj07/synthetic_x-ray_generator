{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/prabhashj07/synthetic_x-ray_generator/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Utils = void 0;\nconst nifti_extension_1 = require(\"./nifti-extension\");\nclass Utils {\n  /*** Static methods ***/\n  static getStringAt(data, start, end) {\n    var str = \"\",\n      ctr,\n      ch;\n    for (ctr = start; ctr < end; ctr += 1) {\n      ch = data.getUint8(ctr);\n      if (ch !== 0) {\n        str += String.fromCharCode(ch);\n      }\n    }\n    return str;\n  }\n  static getIntAt(data, start, littleEndian) {\n    return data.getInt32(start, littleEndian);\n  }\n  static getFloatAt(data, start, littleEndian) {\n    return data.getFloat32(start, littleEndian);\n  }\n  static getDoubleAt(data, start, littleEndian) {\n    return data.getFloat64(start, littleEndian);\n  }\n  static getLongAt(data, start, littleEndian) {\n    var ctr,\n      array = [],\n      value = 0;\n    for (ctr = 0; ctr < 8; ctr += 1) {\n      array[ctr] = Utils.getByteAt(data, start + ctr);\n    }\n    for (ctr = array.length - 1; ctr >= 0; ctr--) {\n      value = value * 256 + array[ctr];\n    }\n    return value;\n  }\n  static getExtensionsAt(data, start, littleEndian, voxOffset) {\n    let extensions = [];\n    let extensionByteIndex = start;\n    // Multiple extended header sections are allowed\n    while (extensionByteIndex < voxOffset) {\n      // assume same endianess as header until proven otherwise\n      let extensionLittleEndian = littleEndian;\n      let esize = Utils.getIntAt(data, extensionByteIndex, littleEndian);\n      if (!esize) {\n        break; // no more extensions\n      }\n      // check if this takes us past vox_offset\n      if (esize + extensionByteIndex > voxOffset) {\n        // check if reversing byte order gets a proper size\n        extensionLittleEndian = !extensionLittleEndian;\n        esize = Utils.getIntAt(data, extensionByteIndex, extensionLittleEndian);\n        if (esize + extensionByteIndex > voxOffset) {\n          throw new Error(\"This does not appear to be a valid NIFTI extension\");\n        }\n      }\n      // esize must be a positive integral multiple of 16\n      if (esize % 16 != 0) {\n        throw new Error(\"This does not appear to be a NIFTI extension\");\n      }\n      let ecode = Utils.getIntAt(data, extensionByteIndex + 4, extensionLittleEndian);\n      let edata = data.buffer.slice(extensionByteIndex + 8, extensionByteIndex + esize);\n      console.log(\"extensionByteIndex: \" + (extensionByteIndex + 8) + \" esize: \" + esize);\n      console.log(edata);\n      let extension = new nifti_extension_1.NIFTIEXTENSION(esize, ecode, edata, extensionLittleEndian);\n      extensions.push(extension);\n      extensionByteIndex += esize;\n    }\n    return extensions;\n  }\n  static toArrayBuffer(buffer) {\n    var ab, view, i;\n    ab = new ArrayBuffer(buffer.length);\n    view = new Uint8Array(ab);\n    for (i = 0; i < buffer.length; i += 1) {\n      view[i] = buffer[i];\n    }\n    return ab;\n  }\n  static isString(obj) {\n    return typeof obj === \"string\" || obj instanceof String;\n  }\n  static formatNumber(num) {\n    let shortFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let val;\n    if (Utils.isString(num)) {\n      val = Number(num);\n    } else {\n      val = num;\n    }\n    if (shortFormat) {\n      val = val.toPrecision(5);\n    } else {\n      val = val.toPrecision(7);\n    }\n    return parseFloat(val);\n  }\n  // http://stackoverflow.com/questions/18638900/javascript-crc32\n  static makeCRCTable() {\n    let c;\n    let crcTable = [];\n    for (var n = 0; n < 256; n++) {\n      c = n;\n      for (var k = 0; k < 8; k++) {\n        c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n      }\n      crcTable[n] = c;\n    }\n    return crcTable;\n  }\n  static crc32(dataView) {\n    if (!Utils.crcTable) {\n      Utils.crcTable = Utils.makeCRCTable();\n    }\n    const crcTable = Utils.crcTable;\n    let crc = 0 ^ -1;\n    for (var i = 0; i < dataView.byteLength; i++) {\n      crc = crc >>> 8 ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xff];\n    }\n    return (crc ^ -1) >>> 0;\n  }\n}\n/*** Static Pseudo-constants ***/\n_defineProperty(Utils, \"crcTable\", null);\n_defineProperty(Utils, \"GUNZIP_MAGIC_COOKIE1\", 31);\n_defineProperty(Utils, \"GUNZIP_MAGIC_COOKIE2\", 139);\n_defineProperty(Utils, \"getByteAt\", function (data, start) {\n  return data.getInt8(start);\n});\n_defineProperty(Utils, \"getShortAt\", function (data, start, littleEndian) {\n  return data.getInt16(start, littleEndian);\n});\nexports.Utils = Utils;","map":{"version":3,"names":["nifti_extension_1","require","Utils","getStringAt","data","start","end","str","ctr","ch","getUint8","String","fromCharCode","getIntAt","littleEndian","getInt32","getFloatAt","getFloat32","getDoubleAt","getFloat64","getLongAt","array","value","getByteAt","length","getExtensionsAt","voxOffset","extensions","extensionByteIndex","extensionLittleEndian","esize","Error","ecode","edata","buffer","slice","console","log","extension","NIFTIEXTENSION","push","toArrayBuffer","ab","view","i","ArrayBuffer","Uint8Array","isString","obj","formatNumber","num","shortFormat","arguments","undefined","val","Number","toPrecision","parseFloat","makeCRCTable","c","crcTable","n","k","crc32","dataView","crc","byteLength","_defineProperty","getInt8","getInt16","exports"],"sources":["/home/prabhashj07/synthetic_x-ray_generator/node_modules/nifti-reader-js/src/utilities.ts"],"sourcesContent":["import { NIFTIEXTENSION } from \"./nifti-extension\";\n\ntype TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array;\n\nexport class Utils {\n  /*** Static Pseudo-constants ***/\n\n  public static crcTable: number[] | null = null;\n  public static readonly GUNZIP_MAGIC_COOKIE1 = 31;\n  public static readonly GUNZIP_MAGIC_COOKIE2 = 139;\n\n  /*** Static methods ***/\n\n  static getStringAt(data: DataView, start: number, end: number): string {\n    var str = \"\",\n      ctr,\n      ch;\n\n    for (ctr = start; ctr < end; ctr += 1) {\n      ch = data.getUint8(ctr);\n\n      if (ch !== 0) {\n        str += String.fromCharCode(ch);\n      }\n    }\n\n    return str;\n  }\n\n  static getByteAt = function (data: DataView, start: number): number {\n    return data.getInt8(start);\n  };\n\n  static getShortAt = function (\n    data: DataView,\n    start: number,\n    littleEndian: boolean\n  ) {\n    return data.getInt16(start, littleEndian);\n  };\n\n  static getIntAt(\n    data: DataView,\n    start: number,\n    littleEndian: boolean\n  ): number {\n    return data.getInt32(start, littleEndian);\n  }\n\n  static getFloatAt(data: DataView, start: number, littleEndian: boolean) {\n    return data.getFloat32(start, littleEndian);\n  }\n\n  static getDoubleAt(data: DataView, start: number, littleEndian: boolean) {\n    return data.getFloat64(start, littleEndian);\n  }\n\n  static getLongAt(data: DataView, start: number, littleEndian: boolean) {\n    var ctr,\n      array = [],\n      value = 0;\n\n    for (ctr = 0; ctr < 8; ctr += 1) {\n      array[ctr] = Utils.getByteAt(data, start + ctr);\n    }\n\n    for (ctr = array.length - 1; ctr >= 0; ctr--) {\n      value = value * 256 + array[ctr];\n    }\n\n    return value;\n  }\n\n  static getExtensionsAt(\n    data: DataView,\n    start: number,\n    littleEndian: boolean,\n    voxOffset: number\n  ) {\n    let extensions = [];\n    let extensionByteIndex = start;\n\n    // Multiple extended header sections are allowed\n    while (extensionByteIndex < voxOffset) {\n      // assume same endianess as header until proven otherwise\n      let extensionLittleEndian = littleEndian;\n      let esize = Utils.getIntAt(data, extensionByteIndex, littleEndian);\n      if (!esize) {\n        break; // no more extensions\n      }\n\n      // check if this takes us past vox_offset\n      if (esize + extensionByteIndex > voxOffset) {\n        // check if reversing byte order gets a proper size\n        extensionLittleEndian = !extensionLittleEndian;\n        esize = Utils.getIntAt(\n          data,\n          extensionByteIndex,\n          extensionLittleEndian\n        );\n        if (esize + extensionByteIndex > voxOffset) {\n          throw new Error(\"This does not appear to be a valid NIFTI extension\");\n        }\n      }\n\n      // esize must be a positive integral multiple of 16\n      if (esize % 16 != 0) {\n        throw new Error(\"This does not appear to be a NIFTI extension\");\n      }\n\n      let ecode = Utils.getIntAt(\n        data,\n        extensionByteIndex + 4,\n        extensionLittleEndian\n      );\n      let edata = data.buffer.slice(\n        extensionByteIndex + 8,\n        extensionByteIndex + esize\n      );\n      console.log(\n        \"extensionByteIndex: \" + (extensionByteIndex + 8) + \" esize: \" + esize\n      );\n      console.log(edata);\n      let extension = new NIFTIEXTENSION(\n        esize,\n        ecode,\n        edata,\n        extensionLittleEndian\n      );\n      extensions.push(extension);\n      extensionByteIndex += esize;\n    }\n    return extensions;\n  }\n\n  static toArrayBuffer(buffer: TypedArray): ArrayBuffer {\n    var ab, view, i;\n\n    ab = new ArrayBuffer(buffer.length);\n    view = new Uint8Array(ab);\n    for (i = 0; i < buffer.length; i += 1) {\n      view[i] = buffer[i];\n    }\n    return ab;\n  }\n\n  static isString(obj: Object): boolean {\n    return typeof obj === \"string\" || obj instanceof String;\n  }\n\n  static formatNumber(\n    num: any,\n    shortFormat: boolean | undefined = undefined\n  ): number {\n    let val;\n\n    if (Utils.isString(num)) {\n      val = Number(num);\n    } else {\n      val = num;\n    }\n\n    if (shortFormat) {\n      val = val.toPrecision(5);\n    } else {\n      val = val.toPrecision(7);\n    }\n\n    return parseFloat(val);\n  }\n\n  // http://stackoverflow.com/questions/18638900/javascript-crc32\n  static makeCRCTable(): number[] {\n    let c;\n    let crcTable: number[] = [];\n    for (var n = 0; n < 256; n++) {\n      c = n;\n      for (var k = 0; k < 8; k++) {\n        c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;\n      }\n      crcTable[n] = c;\n    }\n    return crcTable;\n  }\n\n  static crc32(dataView: DataView): number {\n    if (!Utils.crcTable) {\n      Utils.crcTable = Utils.makeCRCTable();\n    }\n    const crcTable = Utils.crcTable;\n    let crc = 0 ^ -1;\n\n    for (var i = 0; i < dataView.byteLength; i++) {\n      crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xff];\n    }\n\n    return (crc ^ -1) >>> 0;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}